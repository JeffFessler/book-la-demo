<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>RMT and outliers · Demos</title><meta name="title" content="RMT and outliers · Demos"/><meta property="og:title" content="RMT and outliers · Demos"/><meta property="twitter:title" content="RMT and outliers · Demos"/><meta name="description" content="Documentation for Demos."/><meta property="og:description" content="Documentation for Demos."/><meta property="twitter:description" content="Documentation for Demos."/><meta property="og:url" content="https://JeffFessler.github.io/book-la-demo/stable/generated/demos/12/outlier1/"/><meta property="twitter:url" content="https://JeffFessler.github.io/book-la-demo/stable/generated/demos/12/outlier1/"/><link rel="canonical" href="https://JeffFessler.github.io/book-la-demo/stable/generated/demos/12/outlier1/"/><script data-outdated-warner src="../../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../../assets/documenter.js"></script><script src="../../../../search_index.js"></script><script src="../../../../siteinfo.js"></script><script src="../../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../../assets/themeswap.js"></script><link href="../../../../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../../"><img src="../../../../assets/logo.png" alt="Demos logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../../../">Demos</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../../../">Home</a></li><li><span class="tocitem">01 Tutorials</span><ul><li><a class="tocitem" href="../../01/1-intro/">Tutorial: Julia Overview</a></li><li><a class="tocitem" href="../../01/2-vector/">Tutorial: Vectors in Julia</a></li></ul></li><li><span class="tocitem">02 Matrix</span><ul><li><a class="tocitem" href="../../02/conv-mat/">Convolution matrix</a></li><li><a class="tocitem" href="../../02/dot/">Vector dot product</a></li><li><a class="tocitem" href="../../02/gauss2d/">2d heatmap</a></li><li><a class="tocitem" href="../../02/mul-mat-vec/">Matrix-vector product</a></li><li><a class="tocitem" href="../../02/outer/">Vector outer product</a></li></ul></li><li><span class="tocitem">03 Eig/SVD</span><ul><li><a class="tocitem" href="../../03/eig-locus/">Eigenvalue locus</a></li></ul></li><li><span class="tocitem">04 Subspaces</span><ul><li><a class="tocitem" href="../../04/svd-diff/">SVD of finite differences</a></li></ul></li><li><span class="tocitem">05 LS</span><ul><li><a class="tocitem" href="../../05/double-descent/">Double Descent in LS</a></li><li><a class="tocitem" href="../../05/frame-cycle/">Wavelet frame denoising</a></li><li><a class="tocitem" href="../../05/ls-cost1/">LS cost functions</a></li><li><a class="tocitem" href="../../05/ls-cv/">LS fitting with cross validation</a></li><li><a class="tocitem" href="../../05/ls-fit1/">LS fitting</a></li><li><a class="tocitem" href="../../05/ls-lift/">LS lifting</a></li><li><a class="tocitem" href="../../05/sat-regress/">Linear regression and SAT scores</a></li></ul></li><li><span class="tocitem">06 Norm</span><ul><li><a class="tocitem" href="../../06/procrustes/">Procrustes method</a></li><li><a class="tocitem" href="../../06/robust-regress/">Robust regression</a></li></ul></li><li><span class="tocitem">07 Low-Rank</span><ul><li><a class="tocitem" href="../../07/align1/">Image alignment by rank-1 method</a></li><li><a class="tocitem" href="../../07/lr-cv/">Low-Rank Selection via Cross Validation</a></li><li><a class="tocitem" href="../../07/lr-sure/">Low-Rank SURE</a></li><li><a class="tocitem" href="../../07/pca/">PCA</a></li><li><a class="tocitem" href="../../07/photometric3/">Photometric stereo</a></li><li><a class="tocitem" href="../../07/rank1/">Rank-1 approximation</a></li><li><a class="tocitem" href="../../07/source-local/">Source localization</a></li></ul></li><li><span class="tocitem">08 Special</span><ul><li><a class="tocitem" href="../../08/eigmap/">Laplacian eigenmaps</a></li><li><a class="tocitem" href="../../08/kron-sum-inv/">Kronecker sum of circulant</a></li><li><a class="tocitem" href="../../08/markov-chain/">Markov chain</a></li><li><a class="tocitem" href="../../08/spectral-cluster/">Spectral clustering</a></li><li><a class="tocitem" href="../../08/ssc/">Sparse spectral clustering (SSC)</a></li></ul></li><li><span class="tocitem">09 Optimize</span><ul><li><a class="tocitem" href="../../09/class01/">Binary classification</a></li><li><a class="tocitem" href="../../09/logistic1/">Logistic regression</a></li><li><a class="tocitem" href="../../09/precon1/">Preconditioning</a></li></ul></li><li><span class="tocitem">10 Complete</span><ul><li><a class="tocitem" href="../../10/foreback/">Video foreground/background separation</a></li><li><a class="tocitem" href="../../10/lrmc-m/">Low-rank matrix completion: AltMin, ISTA, FISTA</a></li><li><a class="tocitem" href="../../10/lrmc3/">Low-rank matrix completion: ADMM</a></li><li><a class="tocitem" href="../../10/nmf/">Non-negative matrix factorization</a></li></ul></li><li><span class="tocitem">11 Neural nets</span><ul><li><a class="tocitem" href="../../11/ring3/">Classification with MLP</a></li></ul></li><li><span class="tocitem">12 RMT</span><ul><li><a class="tocitem" href="../complete1/">RMT and matrix completion</a></li><li><a class="tocitem" href="../gauss1/">Random matrix theory and rank-1 signal + noise</a></li><li class="is-active"><a class="tocitem" href>RMT and outliers</a><ul class="internal"><li><a class="tocitem" href="#Image-example"><span>Image example</span></a></li><li><a class="tocitem" href="#Latent-matrix"><span>Latent matrix</span></a></li><li><a class="tocitem" href="#Helper-functions"><span>Helper functions</span></a></li><li><a class="tocitem" href="#Noisy-data"><span>Noisy data</span></a></li><li><a class="tocitem" href="#Singular-values"><span>Singular values</span></a></li><li><a class="tocitem" href="#Low-rank-estimate"><span>Low-rank estimate</span></a></li><li><a class="tocitem" href="#Non-iterative-&quot;robust&quot;-PCA"><span>Non-iterative &quot;robust&quot; PCA</span></a></li><li><a class="tocitem" href="#More-outliers"><span>More outliers</span></a></li><li><a class="tocitem" href="#Singular-values-2"><span>Singular values</span></a></li><li><a class="tocitem" href="#Low-rank-estimate-2"><span>Low-rank estimate</span></a></li><li><a class="tocitem" href="#Non-iterative-&quot;robust&quot;-PCA-2"><span>Non-iterative &quot;robust&quot; PCA</span></a></li></ul></li><li><a class="tocitem" href="../round1/">Roundoff errors and rank</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">12 RMT</a></li><li class="is-active"><a href>RMT and outliers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>RMT and outliers</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JeffFessler/book-la-demo" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JeffFessler/book-la-demo/blob/main/docs/lit/demos/12/outlier1.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="outlier1"><a class="docs-heading-anchor" href="#outlier1">RMT and outliers</a><a id="outlier1-1"></a><a class="docs-heading-anchor-permalink" href="#outlier1" title="Permalink"></a></h1><p>This example examines the effects of outliers on SVD performance for estimating a low-rank matrix from noisy data, from the perspective of random matrix theory, using the Julia language.</p><p>This page comes from a single Julia file: <a href="https://github.com/JeffFessler/book-la-demo/blob/main/docs/lit/demos/12/outlier1.jl"><code>outlier1.jl</code></a>.</p><p>You can access the source code for such Julia documentation using the &#39;Edit on GitHub&#39; link in the top right. You can view the corresponding notebook in <a href="https://nbviewer.org/">nbviewer</a> here: <a href="https://nbviewer.org/github/JeffFessler/book-la-demo/tree/gh-pages/generated/demos/12/outlier1.ipynb"><code>outlier1.ipynb</code></a>, or open it in <a href="https://mybinder.org/">binder</a> here: <a href="https://mybinder.org/v2/gh/JeffFessler/book-la-demo/gh-pages?filepath=generated/demos/12/outlier1.ipynb"><code>outlier1.ipynb</code></a>.</p><p>Add the Julia packages that are need for this demo. Change <code>false</code> to <code>true</code> in the following code block if you are using any of the following packages for the first time.</p><pre><code class="language-julia hljs">if false
    import Pkg
    Pkg.add([
        &quot;InteractiveUtils&quot;
        &quot;LaTeXStrings&quot;
        &quot;LinearAlgebra&quot;
        &quot;MIRTjim&quot;
        &quot;Plots&quot;
        &quot;Random&quot;
        &quot;StatsBase&quot;
    ])
end</code></pre><p>Tell Julia to use the following packages for this example. Run <code>Pkg.add()</code> in the preceding code block first, if needed.</p><pre><code class="language-julia hljs">using InteractiveUtils: versioninfo
using LaTeXStrings
using LinearAlgebra: Diagonal, norm, rank, svd, svdvals
using MIRTjim: jim, prompt
using Plots.PlotMeasures: px
using Plots: default, gui, plot, plot!, scatter!, savefig
using Random: seed!
using StatsBase: mean
default(markerstrokecolor=:auto, label=&quot;&quot;, widen=true, markersize = 6,
 labelfontsize = 24, legendfontsize = 18, tickfontsize = 14, linewidth = 3,
)
seed!(0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Random.TaskLocalRNG()</code></pre><p>The following line is helpful when running this file as a script; this way it will prompt user to hit a key after each image is displayed.</p><pre><code class="language-julia hljs">isinteractive() &amp;&amp; prompt(:prompt);</code></pre><h2 id="Image-example"><a class="docs-heading-anchor" href="#Image-example">Image example</a><a id="Image-example-1"></a><a class="docs-heading-anchor-permalink" href="#Image-example" title="Permalink"></a></h2><p>Apply an SVD-based low-rank approximation approach to some data with outliers.</p><h2 id="Latent-matrix"><a class="docs-heading-anchor" href="#Latent-matrix">Latent matrix</a><a id="Latent-matrix-1"></a><a class="docs-heading-anchor-permalink" href="#Latent-matrix" title="Permalink"></a></h2><p>Make a matrix that has low rank:</p><pre><code class="language-julia hljs">tmp = [
    zeros(1,20);
    0 1 0 0 0 0 1 0 0 0 1 1 1 1 0 1 1 1 1 0;
    0 1 0 0 0 0 1 0 0 0 0 1 0 0 1 0 0 1 0 0;
    0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 1 0 0;
    0 0 1 1 1 1 0 0 0 0 1 1 0 0 0 0 0 1 1 0;
    zeros(1,20)
]&#39;;
rank(tmp)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4</code></pre><p>Turn it into an image:</p><pre><code class="language-julia hljs">Xtrue = kron(1 .+ 8*tmp, ones(9,9))
rtrue = rank(Xtrue)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5</code></pre><p>plots with consistent size</p><pre><code class="language-julia hljs">jim1 = (X ; kwargs...) -&gt; jim(X; size = (700,300),
 leftmargin = 10px, rightmargin = 10px, kwargs...);</code></pre><p>and consistent display range</p><pre><code class="language-julia hljs">jimc = (X ; kwargs...) -&gt; jim1(X; clim=(0,9), kwargs...);</code></pre><p>and with NRMSE label</p><pre><code class="language-julia hljs">nrmse = (Xh) -&gt; round(norm(Xh - Xtrue) / norm(Xtrue) * 100, digits=1)
args = (xaxis = false, yaxis = false, colorbar = :none) # book
args = (;) # web
jime = (X; kwargs...) -&gt; jimc(X; xlabel = &quot;NRMSE = $(nrmse(X)) %&quot;,
 args..., kwargs...,
)
bm = s -&gt; &quot;\\mathbf{\\mathit{$s}}&quot;
title = latexstring(&quot;\$$(bm(:X))\$ : Latent image&quot;)
pt = jimc(Xtrue; title, xlabel = &quot; &quot;, args...)</code></pre><img src="17284191.svg" alt="Example block output"/><h2 id="Helper-functions"><a class="docs-heading-anchor" href="#Helper-functions">Helper functions</a><a id="Helper-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Helper-functions" title="Permalink"></a></h2><p>Bernoulli outliers with magnitude <code>τ</code> and probability <code>p</code>:</p><pre><code class="language-julia hljs">function outliers(dims::Dims, τ::Real = 6, p::Real = 0.05)
    Z = τ * sign.(randn(dims)) .* (rand(dims...) .&lt; p)
    return Z
end;</code></pre><h2 id="Noisy-data"><a class="docs-heading-anchor" href="#Noisy-data">Noisy data</a><a id="Noisy-data-1"></a><a class="docs-heading-anchor-permalink" href="#Noisy-data" title="Permalink"></a></h2><pre><code class="language-julia hljs">seed!(0)
(M, N) = size(Xtrue)
Z = outliers((M,N))
Y = Xtrue + Z

title = latexstring(&quot;\$$(bm(:Y))\$ : Corrupted image matrix\n(with outliers)&quot;)
py = jime(Y ; title)</code></pre><img src="d24d57c5.svg" alt="Example block output"/><h2 id="Singular-values"><a class="docs-heading-anchor" href="#Singular-values">Singular values</a><a id="Singular-values-1"></a><a class="docs-heading-anchor-permalink" href="#Singular-values" title="Permalink"></a></h2><p>The first 3 singular values of <span>$Y$</span> are well above the &quot;noise floor&quot; caused by outliers.</p><p>But <span>$σ₄(X)$</span> is just barely above the threshold, and <span>$σ₅(X)$</span> is below the threshold, so we cannot expect a simple SVD approach to recover them well.</p><pre><code class="language-julia hljs">ps1 = plot(
 title = &quot;Singular values&quot;,
 xaxis = (L&quot;k&quot;, (1, N), [1, 3, 6, N]),
 yaxis = (L&quot;σ_k&quot;,),
 leftmargin = 15px, bottommargin = 20px, size = (600,350), widen = true,
)
sv_x = svdvals(Xtrue)
sv_y = svdvals(Y)
scatter!(sv_y, color=:red, label=&quot;Y (data)&quot;, marker=:dtriangle)
scatter!(sv_x, color=:blue, label=&quot;Xtrue&quot;, marker=:utriangle)</code></pre><img src="e429300d.svg" alt="Example block output"/><pre><code class="language-julia hljs">prompt()</code></pre><h2 id="Low-rank-estimate"><a class="docs-heading-anchor" href="#Low-rank-estimate">Low-rank estimate</a><a id="Low-rank-estimate-1"></a><a class="docs-heading-anchor-permalink" href="#Low-rank-estimate" title="Permalink"></a></h2><p>A simple low-rank estimate of <span>$X$</span> from the first few SVD components of <span>$Y$</span> works just so-so here. A simple SVD approach recovers the first 3 components well, but cannot estimate the 4th and 5th components.</p><pre><code class="language-julia hljs">r = 5
U,s,V = svd(Y)
Xr = U[:,1:r] * Diagonal(s[1:r]) * V[:,1:r]&#39;
title = latexstring(&quot;Rank $r approximation of data \$$(bm(:Y))\$&quot;)
pr = jime(Xr ; title)</code></pre><img src="abc0e888.svg" alt="Example block output"/><p>Examine singular vector estimates. The first 3 are quite good; the next two are poor.</p><pre><code class="language-julia hljs">sv1 = [
 sum(svd(Xr).U[:,1:r] .* svd(Xtrue).U[:,1:r], dims=1).^2
 sum(svd(Xr).V[:,1:r] .* svd(Xtrue).V[:,1:r], dims=1).^2
]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×5 Matrix{Float64}:
 0.997259  0.985004  0.981207  0.85263   0.606551
 0.999109  0.993145  0.991356  0.942252  0.83442</code></pre><h2 id="Non-iterative-&quot;robust&quot;-PCA"><a class="docs-heading-anchor" href="#Non-iterative-&quot;robust&quot;-PCA">Non-iterative &quot;robust&quot; PCA</a><a id="Non-iterative-&quot;robust&quot;-PCA-1"></a><a class="docs-heading-anchor-permalink" href="#Non-iterative-&quot;robust&quot;-PCA" title="Permalink"></a></h2><p>Try simple outlier removal method. Look at the residual between <span>$\hat{X}$</span> and <span>$Y$</span>:</p><pre><code class="language-julia hljs">residual = Xr - Y

pd = jim1(residual; clim = (-1,1) .* 7, cticks = (-1:1:1) * 8,
 title = latexstring(&quot;Residual \$$(bm(:Y)) - \\hat{$(bm(:X))}\$&quot;),
)</code></pre><img src="2c48ac07.svg" alt="Example block output"/><p>Identify &quot;bad&quot; pixels with large residual errors</p><pre><code class="language-julia hljs">badpixel = @. abs(residual) &gt; 3
jim1(badpixel)</code></pre><img src="94e5a23e.svg" alt="Example block output"/><p>Replace &quot;bad&quot; pixels with typical image values</p><pre><code class="language-julia hljs">Ymod = copy(Y)
Ymod[badpixel] .= mean(Y[.!badpixel])
jime(Ymod) # already reduces NRMSE by a lot compared to Y itself!</code></pre><img src="e1b5d568.svg" alt="Example block output"/><p>Examine singular values of modified <span>$Y$</span>. The noise floor is lower.</p><pre><code class="language-julia hljs">ps2 = plot(
 title = &quot;Singular values&quot;,
 xaxis = (L&quot;k&quot;, (1, N), [1, 3, 6, N]),
 yaxis = (L&quot;σ_k&quot;,),
 leftmargin = 15px, bottommargin = 20px, size = (600,350), widen = true,
)
sv_f = svdvals(Ymod)
scatter!(sv_f, color=:green, label=&quot;Y (modified)&quot;, marker=:hex)
scatter!(sv_x, color=:blue, label=&quot;Xtrue&quot;, marker=:utriangle)</code></pre><img src="d4f2ce7f.svg" alt="Example block output"/><pre><code class="language-julia hljs">prompt()</code></pre><p>Applying low-rank matrix approximation to modified <span>$Y$</span> leads to lower NRMSE.</p><pre><code class="language-julia hljs">Um,sm,Vm = svd(Ymod)
Xh = Um[:,1:r] * Diagonal(sm[1:r]) * Vm[:,1:r]&#39;
title = latexstring(&quot;Rank $r approximation of modified data \$$(bm(:Y))\$&quot;)
ph = jime(Xh ; title)</code></pre><img src="d212b634.svg" alt="Example block output"/><p>All of the singular components are better recovered, including the ones that were near or below the noise threshold.</p><pre><code class="language-julia hljs">sv2 = [
 sum(svd(Xh).U[:,1:r] .* svd(Xtrue).U[:,1:r], dims=1).^2
 sum(svd(Xh).V[:,1:r] .* svd(Xtrue).V[:,1:r], dims=1).^2
]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×5 Matrix{Float64}:
 0.998662  0.99398   0.991446  0.964283  0.940057
 0.999397  0.998669  0.998008  0.9779    0.954923</code></pre><p>Summary</p><pre><code class="language-julia hljs">pa = jim(stack((Xtrue, abs.(Z), Y, Xr, 6*badpixel, Xh));
 ncol=1, size=(600, 900), clim=(0,9))</code></pre><img src="819437da.svg" alt="Example block output"/><h2 id="More-outliers"><a class="docs-heading-anchor" href="#More-outliers">More outliers</a><a id="More-outliers-1"></a><a class="docs-heading-anchor-permalink" href="#More-outliers" title="Permalink"></a></h2><p>Now examine a case where the outliers are stronger and more prevalent.</p><pre><code class="language-julia hljs">pout2 = 0.1
Z = outliers((M,N), 50, pout2)
Y = Xtrue + Z

title = latexstring(&quot;\$$(bm(:Y))\$ : Corrupted image matrix\n(with $(100*pout2)% outliers)&quot;)
py2 = jime(Y ; title)</code></pre><img src="a065bc1b.svg" alt="Example block output"/><h2 id="Singular-values-2"><a class="docs-heading-anchor" href="#Singular-values-2">Singular values</a><a class="docs-heading-anchor-permalink" href="#Singular-values-2" title="Permalink"></a></h2><p>Now all of the singular values of <span>$X$</span> are below the &quot;noise floor&quot; caused by outliers.</p><pre><code class="language-julia hljs">ps3 = plot(
 title = &quot;Singular values&quot;,
 xaxis = (L&quot;k&quot;, (1, N), [1, 3, 6, N]),
 yaxis = (L&quot;σ_k&quot;,),
 leftmargin = 15px, bottommargin = 20px, size = (600,350), widen = true,
)
sv_x = svdvals(Xtrue)
sv_y = svdvals(Y)
scatter!(sv_y, color=:red, label=&quot;Y (data)&quot;, marker=:dtriangle)
scatter!(sv_x, color=:blue, label=&quot;Xtrue&quot;, marker=:utriangle)</code></pre><img src="754741ba.svg" alt="Example block output"/><pre><code class="language-julia hljs">prompt()</code></pre><h2 id="Low-rank-estimate-2"><a class="docs-heading-anchor" href="#Low-rank-estimate-2">Low-rank estimate</a><a class="docs-heading-anchor-permalink" href="#Low-rank-estimate-2" title="Permalink"></a></h2><p>A simple low-rank estimate of <span>$X$</span> from the first few SVD components of <span>$Y$</span> does not work at all now for such heavily corrupted data.</p><pre><code class="language-julia hljs">r = 5
U,s,V = svd(Y)
Xr = U[:,1:r] * Diagonal(s[1:r]) * V[:,1:r]&#39;
title = latexstring(&quot;Rank $r approximation of data \$$(bm(:Y))\$&quot;)
pr2 = jime(Xr ; title)</code></pre><img src="e86796d6.svg" alt="Example block output"/><p>Examine singular vector estimates. The first one is so-so, the rest are useless.</p><pre><code class="language-julia hljs">sv3 = [
 sum(svd(Xr).U[:,1:r] .* svd(Xtrue).U[:,1:r], dims=1).^2
 sum(svd(Xr).V[:,1:r] .* svd(Xtrue).V[:,1:r], dims=1).^2
]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×5 Matrix{Float64}:
 0.696924  0.0419613  0.0178384  9.77862e-6  0.00170552
 0.861749  0.113886   0.0130079  0.0265428   0.00290215</code></pre><h2 id="Non-iterative-&quot;robust&quot;-PCA-2"><a class="docs-heading-anchor" href="#Non-iterative-&quot;robust&quot;-PCA-2">Non-iterative &quot;robust&quot; PCA</a><a class="docs-heading-anchor-permalink" href="#Non-iterative-&quot;robust&quot;-PCA-2" title="Permalink"></a></h2><p>Try simple outlier removal method. Look at the residual between <span>$\hat{X}$</span> and <span>$Y$</span>:</p><pre><code class="language-julia hljs">residual = Xr - Y

pd2 = jim1(residual; clim = (-1,1) .* 70, cticks = (-1:1:1) * 8,
 title = latexstring(&quot;Residual \$$(bm(:Y)) - \\hat{$(bm(:X))}\$&quot;),
)</code></pre><img src="49dfd134.svg" alt="Example block output"/><p>Identify &quot;bad&quot; pixels with large residual errors. This is a nonlinear operation:</p><pre><code class="language-julia hljs">badpixel = @. abs(residual) &gt; 10
jim1(badpixel)</code></pre><img src="08f11664.svg" alt="Example block output"/><p>Replace &quot;bad&quot; pixels with typical image values</p><pre><code class="language-julia hljs">Ymod = copy(Y)
Ymod[badpixel] .= mean(Y[.!badpixel])
jime(Ymod) # already reduces NRMSE by a lot compared to Y itself!</code></pre><img src="31abb567.svg" alt="Example block output"/><p>Examine singular values of modified <span>$Y$</span>. The noise floor is lower.</p><pre><code class="language-julia hljs">ps4 = plot(
 title = &quot;Singular values&quot;,
 xaxis = (L&quot;k&quot;, (1, N), [1, 3, 6, N]),
 yaxis = (L&quot;σ_k&quot;,),
 leftmargin = 15px, bottommargin = 20px, size = (600,350), widen = true,
)
sv_f = svdvals(Ymod)
scatter!(sv_f, color=:green, label=&quot;Y (modified)&quot;, marker=:hex)
scatter!(sv_x, color=:blue, label=&quot;Xtrue&quot;, marker=:utriangle)</code></pre><img src="918931f2.svg" alt="Example block output"/><pre><code class="language-julia hljs">prompt()</code></pre><p>Applying low-rank matrix approximation to modified <span>$Y$</span> leads to lower NRMSE.</p><pre><code class="language-julia hljs">Um,sm,Vm = svd(Ymod)
Xh = Um[:,1:r] * Diagonal(sm[1:r]) * Vm[:,1:r]&#39;
title = latexstring(&quot;Rank $r approximation of modified data \$$(bm(:Y))\$&quot;)
ph2 = jime(Xh ; title)</code></pre><img src="ac7b9976.svg" alt="Example block output"/><p>Now the first three singular components are better recovered.</p><pre><code class="language-julia hljs">sv4 = [
 sum(svd(Xh).U[:,1:r] .* svd(Xtrue).U[:,1:r], dims=1).^2
 sum(svd(Xh).V[:,1:r] .* svd(Xtrue).V[:,1:r], dims=1).^2
]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×5 Matrix{Float64}:
 0.981316  0.867786  0.762916  0.0147503   0.0583367
 0.987833  0.968847  0.735703  0.00146397  0.139768</code></pre><p>Let&#39;s try iterating to see if we can refine it. Indeed it does refine it, but at this point it starts to become an ad hoc iterative method. If we going to iterate, then it seems preferable to use a cost function like the one used in robust PCA, with a proper optimization algorithm.</p><pre><code class="language-julia hljs">residual = Xh - Y
badpixel = @. abs(residual) &gt; 10
jim1(badpixel)
Ymod = copy(Y)
Ymod[badpixel] .= mean(Y[.!badpixel])
Um,sm,Vm = svd(Ymod)
Xh3 = Um[:,1:r] * Diagonal(sm[1:r]) * Vm[:,1:r]&#39;
title = latexstring(&quot;Rank $r approximation of modified data \$$(bm(:Y))\$&quot;)
ph3 = jime(Xh3 ; title)</code></pre><img src="7904b499.svg" alt="Example block output"/><h3 id="Reproducibility"><a class="docs-heading-anchor" href="#Reproducibility">Reproducibility</a><a id="Reproducibility-1"></a><a class="docs-heading-anchor-permalink" href="#Reproducibility" title="Permalink"></a></h3><p>This page was generated with the following version of Julia:</p><pre><code class="language-julia hljs">using InteractiveUtils: versioninfo
io = IOBuffer(); versioninfo(io); split(String(take!(io)), &#39;\n&#39;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">12-element Vector{SubString{String}}:
 &quot;Julia Version 1.12.5&quot;
 &quot;Commit 5fe89b8ddc1 (2026-02-09 16:05 UTC)&quot;
 &quot;Build Info:&quot;
 &quot;  Official https://julialang.org release&quot;
 &quot;Platform Info:&quot;
 &quot;  OS: Linux (x86_64-linux-gnu)&quot;
 &quot;  CPU: 4 × AMD EPYC 7763 64-Core Processor&quot;
 &quot;  WORD_SIZE: 64&quot;
 &quot;  LLVM: libLLVM-18.1.7 (ORCJIT, znver3)&quot;
 &quot;  GC: Built with stock GC&quot;
 &quot;Threads: 1 default, 1 interactive, 1 GC (on 4 virtual cores)&quot;
 &quot;&quot;</code></pre><p>And with the following package versions</p><pre><code class="language-julia hljs">import Pkg; Pkg.status()</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr32"><span class="sgr1">Status</span></span> `~/work/book-la-demo/book-la-demo/docs/Project.toml`
  <span class="sgr90">[6e4b80f9] </span>BenchmarkTools v1.6.3
  <span class="sgr90">[aaaa29a8] </span>Clustering v0.15.8
  <span class="sgr90">[35d6a980] </span>ColorSchemes v3.31.0
  <span class="sgr90">[3da002f7] </span>ColorTypes v0.12.1
  <span class="sgr90">[c3611d14] </span>ColorVectorSpace v0.11.0
  <span class="sgr90">[717857b8] </span>DSP v0.8.4
  <span class="sgr90">[72c85766] </span>Demos v0.1.0 `~/work/book-la-demo/book-la-demo`
  <span class="sgr90">[e30172f5] </span>Documenter v1.16.1
  <span class="sgr90">[4f61f5a4] </span>FFTViews v0.3.2
  <span class="sgr90">[7a1cc6ca] </span>FFTW v1.10.0
  <span class="sgr90">[587475ba] </span>Flux v0.16.9
  <span class="sgr90">[a09fc81d] </span>ImageCore v0.10.5
  <span class="sgr90">[9ee76f2b] </span>ImageGeoms v0.11.2
  <span class="sgr90">[71a99df6] </span>ImagePhantoms v0.8.1
  <span class="sgr90">[b964fa9f] </span>LaTeXStrings v1.4.0
  <span class="sgr90">[7031d0ef] </span>LazyGrids v1.1.0
  <span class="sgr90">[599c1a8e] </span>LinearMapsAA v0.12.0
  <span class="sgr90">[98b081ad] </span>Literate v2.21.0
  <span class="sgr90">[7035ae7a] </span>MIRT v0.18.3
  <span class="sgr90">[170b2178] </span>MIRTjim v0.26.0
  <span class="sgr90">[eb30cadb] </span>MLDatasets v0.7.20
  <span class="sgr90">[efe261a4] </span>NFFT v0.14.3
  <span class="sgr90">[6ef6ca0d] </span>NMF v1.0.3
  <span class="sgr90">[15e1cf62] </span>NPZ v0.4.3
  <span class="sgr90">[0b1bfda6] </span>OneHotArrays v0.2.10
  <span class="sgr90">[429524aa] </span>Optim v2.0.1
  <span class="sgr90">[91a5bcdd] </span>Plots v1.41.5
  <span class="sgr90">[f27b6e38] </span>Polynomials v4.1.0
  <span class="sgr90">[2913bbd2] </span>StatsBase v0.34.10
  <span class="sgr90">[1986cc42] </span>Unitful v1.28.0
  <span class="sgr90">[d6d074c3] </span>VideoIO v1.4.0
  <span class="sgr90">[b77e0a4c] </span>InteractiveUtils v1.11.0
  <span class="sgr90">[37e2e46d] </span>LinearAlgebra v1.12.0
  <span class="sgr90">[44cfe95a] </span>Pkg v1.12.1
  <span class="sgr90">[9a3f8284] </span>Random v1.11.0</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../gauss1/">« Random matrix theory and rank-1 signal + noise</a><a class="docs-footer-nextpage" href="../round1/">Roundoff errors and rank »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Saturday 14 February 2026 16:44">Saturday 14 February 2026</span>. Using Julia version 1.12.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
